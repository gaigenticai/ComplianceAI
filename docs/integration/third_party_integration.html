<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Third-Party Integration Guide - ComplianceAI</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 40px;
            color: #2c3e50;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .header p {
            font-size: 1.2em;
            color: #7f8c8d;
        }
        .nav-tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 2px solid #e74c3c;
            overflow-x: auto;
        }
        .nav-tab {
            padding: 15px 25px;
            background: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            color: #495057;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            background: #e74c3c;
            color: white;
        }
        .nav-tab:hover {
            background: #dee2e6;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .section {
            margin-bottom: 40px;
        }
        .section h2 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            font-size: 1.8em;
        }
        .section h3 {
            color: #34495e;
            font-size: 1.4em;
            margin-top: 30px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        .highlight {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
        }
        .warning {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
        }
        .success {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
        }
        .config-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .config-table th,
        .config-table td {
            border: 1px solid #dee2e6;
            padding: 12px;
            text-align: left;
        }
        .config-table th {
            background: #f8f9fa;
            font-weight: 600;
        }
        .config-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        .step-list {
            counter-reset: step-counter;
        }
        .step-list li {
            counter-increment: step-counter;
            margin-bottom: 15px;
            padding-left: 40px;
            position: relative;
        }
        .step-list li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #3498db;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .api-endpoint {
            background: #e8f4f8;
            border: 1px solid #bee5eb;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        .api-endpoint .method {
            font-weight: bold;
            color: #0056b3;
        }
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Third-Party Integration Guide</h1>
            <p>Comprehensive guide for integrating ComplianceAI with external regulatory systems</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('eba')">EBA Integration</button>
            <button class="nav-tab" onclick="showTab('sftp')">SFTP Delivery</button>
            <button class="nav-tab" onclick="showTab('regulatory-data')">Regulatory Data</button>
            <button class="nav-tab" onclick="showTab('banking-apis')">Banking APIs</button>
            <button class="nav-tab" onclick="showTab('monitoring')">Monitoring</button>
            <button class="nav-tab" onclick="showTab('security')">Security</button>
        </div>

        <!-- EBA Integration Tab -->
        <div id="eba" class="tab-content active">
            <div class="section">
                <h2>European Banking Authority (EBA) Integration</h2>
                <p>The ComplianceAI system integrates with the EBA Reporting framework to automatically submit regulatory reports and receive confirmations.</p>

                <h3>OAuth 2.0 Authentication Setup</h3>
                <div class="step-list">
                    <li>Register your institution with the EBA Reporting API</li>
                    <li>Obtain client credentials (client_id and client_secret)</li>
                    <li>Configure OAuth 2.0 endpoints in your environment</li>
                    <li>Implement token refresh mechanism with automatic retry</li>
                    <li>Set up certificate-based authentication for production</li>
                </div>

                <h3>Configuration</h3>
                <table class="config-table">
                    <thead>
                        <tr>
                            <th>Environment Variable</th>
                            <th>Description</th>
                            <th>Example Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>EBA_CLIENT_ID</td>
                            <td>EBA API client identifier</td>
                            <td>your-institution-client-id</td>
                        </tr>
                        <tr>
                            <td>EBA_CLIENT_SECRET</td>
                            <td>EBA API client secret</td>
                            <td>your-secure-client-secret</td>
                        </tr>
                        <tr>
                            <td>EBA_BASE_URL</td>
                            <td>EBA API base URL</td>
                            <td>https://api.eba.europa.eu</td>
                        </tr>
                        <tr>
                            <td>EBA_TOKEN_URL</td>
                            <td>OAuth 2.0 token endpoint</td>
                            <td>https://api.eba.europa.eu/oauth/token</td>
                        </tr>
                    </tbody>
                </table>

                <h3>API Integration Example</h3>
                <div class="code-block">
# EBA API Integration Example
import aiohttp
import asyncio
from typing import Dict, Any

class EBAApiClient:
    """
    EBA API client for regulatory report submission
    Handles OAuth 2.0 authentication and report delivery
    """

    def __init__(self, client_id: str, client_secret: str, base_url: str):
        self.client_id = client_id
        self.client_secret = client_secret
        self.base_url = base_url
        self.token_url = f"{base_url}/oauth/token"
        self.access_token = None
        self.session = None

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def authenticate(self) -> bool:
        """
        Authenticate with EBA using OAuth 2.0 client credentials flow
        Returns True if authentication successful
        """
        try:
            auth_data = {
                'grant_type': 'client_credentials',
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'scope': 'reporting'
            }

            async with self.session.post(self.token_url, data=auth_data) as response:
                if response.status == 200:
                    token_data = await response.json()
                    self.access_token = token_data.get('access_token')
                    return True
                else:
                    print(f"EBA Authentication failed: {response.status}")
                    return False
        except Exception as e:
            print(f"EBA Authentication error: {str(e)}")
            return False

    async def submit_report(self, report_data: Dict[str, Any], report_type: str) -> Dict[str, Any]:
        """
        Submit regulatory report to EBA
        Args:
            report_data: Report data in EBA format
            report_type: Type of report (FINREP, COREP, etc.)
        Returns:
            Submission response from EBA
        """
        if not self.access_token:
            if not await self.authenticate():
                raise Exception("Failed to authenticate with EBA")

        headers = {
            'Authorization': f'Bearer {self.access_token}',
            'Content-Type': 'application/json',
            'X-Report-Type': report_type
        }

        submit_url = f"{self.base_url}/reporting/submit"

        try:
            async with self.session.post(submit_url, json=report_data, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                elif response.status == 401:
                    # Token expired, retry with new token
                    self.access_token = None
                    if await self.authenticate():
                        return await self.submit_report(report_data, report_type)
                    else:
                        raise Exception("Failed to refresh EBA token")
                else:
                    error_data = await response.json()
                    raise Exception(f"EBA submission failed: {error_data.get('message', 'Unknown error')}")
        except Exception as e:
            print(f"EBA submission error: {str(e)}")
            raise

    async def get_submission_status(self, submission_id: str) -> Dict[str, Any]:
        """
        Check status of submitted report
        Args:
            submission_id: Unique submission identifier from EBA
        Returns:
            Status information
        """
        if not self.access_token:
            if not await self.authenticate():
                raise Exception("Failed to authenticate with EBA")

        headers = {'Authorization': f'Bearer {self.access_token}'}
        status_url = f"{self.base_url}/reporting/status/{submission_id}"

        async with self.session.get(status_url, headers=headers) as response:
            if response.status == 200:
                return await response.json()
            else:
                raise Exception(f"Failed to get submission status: {response.status}")
                </div>

                <h3>Report Format Standards</h3>
                <div class="highlight">
                    <strong>EBA Report Formats Supported:</strong>
                    <ul>
                        <li>FINREP (Financial Reporting) - XBRL format</li>
                        <li>COREP (COmmon REPorting) - XBRL format</li>
                        <li>DORA ICT Risk - JSON format</li>
                        <li>AML/CFT Reporting - CSV format</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- SFTP Delivery Tab -->
        <div id="sftp" class="tab-content">
            <div class="section">
                <h2>SFTP Delivery Integration</h2>
                <p>Secure file transfer protocol integration for delivering regulatory reports to supervisory authorities.</p>

                <h3>SFTP Configuration</h3>
                <table class="config-table">
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Description</th>
                            <th>Security Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>SFTP_HOST</td>
                            <td>Regulatory authority SFTP server</td>
                            <td>Use TLS 1.3+ encryption</td>
                        </tr>
                        <tr>
                            <td>SFTP_PORT</td>
                            <td>SFTP port (default 22)</td>
                            <td>Standard SSH port</td>
                        </tr>
                        <tr>
                            <td>SFTP_USERNAME</td>
                            <td>Institution username</td>
                            <td>Use unique credentials per institution</td>
                        </tr>
                        <tr>
                            <td>SFTP_KEY_PATH</td>
                            <td>Path to private key file</td>
                            <td>Store securely, rotate regularly</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Secure SFTP Implementation</h3>
                <div class="code-block">
# Secure SFTP Delivery Implementation
import asyncssh
import aiofiles
import asyncio
from pathlib import Path
from typing import Optional, Dict, Any
import logging

logger = logging.getLogger(__name__)

class SecureSFTPDelivery:
    """
    Secure SFTP delivery for regulatory reports
    Implements encryption, digital signatures, and audit logging
    """

    def __init__(self,
                 host: str,
                 port: int,
                 username: str,
                 key_path: str,
                 known_hosts_path: Optional[str] = None):
        self.host = host
        self.port = port
        self.username = username
        self.key_path = Path(key_path)
        self.known_hosts_path = known_hosts_path or str(Path.home() / '.ssh' / 'known_hosts')

    async def deliver_report(self,
                           local_file_path: str,
                           remote_file_path: str,
                           report_metadata: Dict[str, Any]) -> bool:
        """
        Deliver regulatory report via SFTP with security measures
        Args:
            local_file_path: Path to local report file
            remote_file_path: Destination path on SFTP server
            report_metadata: Report metadata for audit logging
        Returns:
            True if delivery successful
        """
        try:
            # Validate file exists and is readable
            if not Path(local_file_path).exists():
                raise FileNotFoundError(f"Report file not found: {local_file_path}")

            # Establish secure SFTP connection
            async with asyncssh.connect(
                self.host,
                port=self.port,
                username=self.username,
                client_keys=[self.key_path],
                known_hosts=self.known_hosts_path,
                # Security options
                kex_algs=['curve25519-sha256', 'diffie-hellman-group16-sha512'],
                encryption_algs=['aes256-gcm@openssh.com', 'aes256-ctr'],
                mac_algs=['hmac-sha2-512', 'hmac-sha2-256']
            ) as conn:
                async with conn.start_sftp_client() as sftp:
                    # Create remote directory if it doesn't exist
                    remote_dir = str(Path(remote_file_path).parent)
                    try:
                        await sftp.makedirs(remote_dir, exist_ok=True)
                    except asyncssh.SFTPError:
                        pass  # Directory might already exist

                    # Upload file with progress tracking
                    await sftp.put(local_file_path, remote_file_path)

                    # Verify upload integrity
                    local_stat = Path(local_file_path).stat()
                    remote_stat = await sftp.stat(remote_file_path)

                    if local_stat.st_size != remote_stat.size:
                        raise Exception("File size mismatch after upload")

                    # Log successful delivery
                    logger.info(f"Report delivered successfully: {report_metadata}")
                    return True

        except asyncssh.SFTPError as e:
            logger.error(f"SFTP delivery failed: {str(e)}")
            raise
        except Exception as e:
            logger.error(f"SFTP delivery error: {str(e)}")
            raise

    async def verify_delivery(self, remote_file_path: str) -> Dict[str, Any]:
        """
        Verify successful delivery and get file metadata
        Args:
            remote_file_path: Path to verify on SFTP server
        Returns:
            File metadata from SFTP server
        """
        try:
            async with asyncssh.connect(
                self.host,
                port=self.port,
                username=self.username,
                client_keys=[self.key_path],
                known_hosts=self.known_hosts_path
            ) as conn:
                async with conn.start_sftp_client() as sftp:
                    stat = await sftp.stat(remote_file_path)
                    return {
                        'size': stat.size,
                        'mtime': stat.mtime,
                        'permissions': oct(stat.permissions),
                        'exists': True
                    }
        except asyncssh.SFTPError:
            return {'exists': False, 'error': 'File not found on server'}
        except Exception as e:
            return {'exists': False, 'error': str(e)}
                </div>

                <h3>Security Best Practices</h3>
                <div class="warning">
                    <strong>Critical Security Requirements:</strong>
                    <ul>
                        <li>Use SSH key authentication (no passwords)</li>
                        <li>Rotate SSH keys every 90 days</li>
                        <li>Implement file integrity verification (SHA-256)</li>
                        <li>Use TLS 1.3 for all connections</li>
                        <li>Log all SFTP operations for audit trail</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Regulatory Data Tab -->
        <div id="regulatory-data" class="tab-content">
            <div class="section">
                <h2>Regulatory Data Provider Integration</h2>
                <p>Integration with external regulatory data sources for real-time compliance updates.</p>

                <h3>Supported Data Sources</h3>
                <ul>
                    <li><strong>EBA Data Portal:</strong> Official regulatory data and templates</li>
                    <li><strong>ESMA Registers:</strong> Financial instrument reference data</li>
                    <li><strong>National Regulators:</strong> Country-specific requirements</li>
                    <li><strong>AML Databases:</strong> Sanctions and watchlist data</li>
                    <li><strong>Credit Rating Agencies:</strong> Rating data for risk assessment</li>
                </ul>

                <h3>Data Synchronization Process</h3>
                <div class="step-list">
                    <li>Configure data source endpoints and authentication</li>
                    <li>Set up scheduled synchronization jobs</li>
                    <li>Implement data validation and cleansing</li>
                    <li>Handle data versioning and change tracking</li>
                    <li>Set up monitoring and alerting for data quality</li>
                </div>

                <h3>Data Quality Assurance</h3>
                <div class="code-block">
# Regulatory Data Quality Assurance
import pandas as pd
from datetime import datetime, timedelta
from typing import List, Dict, Any
import logging

logger = logging.getLogger(__name__)

class RegulatoryDataValidator:
    """
    Validates quality and completeness of regulatory data
    Ensures data meets compliance standards before processing
    """

    def __init__(self, data_source: str):
        self.data_source = data_source
        self.validation_rules = self._load_validation_rules()

    def _load_validation_rules(self) -> Dict[str, Any]:
        """Load validation rules for different data types"""
        return {
            'sanctions_data': {
                'required_fields': ['entity_name', 'entity_type', 'list_type'],
                'date_fields': ['listing_date', 'last_updated'],
                'duplicate_check': ['entity_name', 'country']
            },
            'regulatory_templates': {
                'required_fields': ['template_id', 'version', 'effective_date'],
                'schema_validation': True,
                'business_rules_check': True
            }
        }

    def validate_dataset(self, data: pd.DataFrame, data_type: str) -> Dict[str, Any]:
        """
        Comprehensive validation of regulatory dataset
        Args:
            data: Dataset to validate
            data_type: Type of regulatory data
        Returns:
            Validation results with issues and recommendations
        """
        results = {
            'is_valid': True,
            'issues': [],
            'recommendations': [],
            'quality_score': 100
        }

        rules = self.validation_rules.get(data_type, {})

        # Check required fields
        missing_fields = self._check_required_fields(data, rules.get('required_fields', []))
        if missing_fields:
            results['issues'].append(f"Missing required fields: {missing_fields}")
            results['is_valid'] = False
            results['quality_score'] -= len(missing_fields) * 10

        # Validate date fields
        date_issues = self._validate_date_fields(data, rules.get('date_fields', []))
        if date_issues:
            results['issues'].extend(date_issues)
            results['quality_score'] -= len(date_issues) * 5

        # Check for duplicates
        duplicate_issues = self._check_duplicates(data, rules.get('duplicate_check', []))
        if duplicate_issues:
            results['issues'].append(f"Duplicate records found: {duplicate_issues}")
            results['quality_score'] -= duplicate_issues * 15

        # Data completeness check
        completeness = self._calculate_completeness(data)
        if completeness < 95:
            results['recommendations'].append(".1f"
        # Data freshness check
        freshness_issues = self._check_data_freshness(data)
        if freshness_issues:
            results['issues'].extend(freshness_issues)
            results['quality_score'] -= len(freshness_issues) * 8

        results['quality_score'] = max(0, results['quality_score'])

        if results['issues']:
            results['is_valid'] = False

        return results

    def _check_required_fields(self, data: pd.DataFrame, required_fields: List[str]) -> List[str]:
        """Check for missing required fields"""
        missing = []
        for field in required_fields:
            if field not in data.columns or data[field].isnull().all():
                missing.append(field)
        return missing

    def _validate_date_fields(self, data: pd.DataFrame, date_fields: List[str]) -> List[str]:
        """Validate date field formats and ranges"""
        issues = []
        for field in date_fields:
            if field in data.columns:
                try:
                    pd.to_datetime(data[field], errors='coerce')
                    # Check for future dates (data shouldn't be from future)
                    future_dates = data[pd.to_datetime(data[field]) > datetime.now()]
                    if not future_dates.empty:
                        issues.append(f"Future dates found in {field}")
                except Exception as e:
                    issues.append(f"Invalid date format in {field}: {str(e)}")
        return issues

    def _check_duplicates(self, data: pd.DataFrame, duplicate_fields: List[str]) -> int:
        """Check for duplicate records"""
        if duplicate_fields and all(field in data.columns for field in duplicate_fields):
            duplicates = data.duplicated(subset=duplicate_fields, keep=False).sum()
            return duplicates
        return 0

    def _calculate_completeness(self, data: pd.DataFrame) -> float:
        """Calculate percentage of non-null values"""
        total_cells = data.shape[0] * data.shape[1]
        non_null_cells = data.notnull().sum().sum()
        return (non_null_cells / total_cells) * 100 if total_cells > 0 else 0

    def _check_data_freshness(self, data: pd.DataFrame) -> List[str]:
        """Check if data is sufficiently fresh"""
        issues = []
        cutoff_date = datetime.now() - timedelta(days=30)  # 30 days threshold

        date_columns = ['last_updated', 'effective_date', 'created_date']
        for col in date_columns:
            if col in data.columns:
                try:
                    old_data = data[pd.to_datetime(data[col]) < cutoff_date]
                    if not old_data.empty:
                        issues.append(f"Stale data found in {col}: {len(old_data)} records older than 30 days")
                except:
                    continue

        return issues
                </div>
            </div>
        </div>

        <!-- Banking APIs Tab -->
        <div id="banking-apis" class="tab-content">
            <div class="section">
                <h2>Banking System API Integration</h2>
                <p>Integration with internal banking systems for data collection and report generation.</p>

                <h3>Supported Banking APIs</h3>
                <ul>
                    <li><strong>Core Banking Systems:</strong> SAP, Temenos, FIS, Oracle FLEXCUBE</li>
                    <li><strong>Risk Management Systems:</strong> MSCI RiskManager, SAS Risk</li>
                    <li><strong>Treasury Systems:</strong> Bloomberg, Reuters, Summit</li>
                    <li><strong>General Ledger:</strong> SAP FI, Oracle GL, Microsoft Dynamics</li>
                </ul>

                <h3>API Authentication Methods</h3>
                <div class="api-endpoint">
                    <div class="method">OAuth 2.0 Client Credentials</div>
                    <p>For system-to-system authentication with banking APIs</p>
                </div>
                <div class="api-endpoint">
                    <div class="method">JWT Bearer Tokens</div>
                    <p>For secure API communication with token expiration handling</p>
                </div>
                <div class="api-endpoint">
                    <div class="method">API Key Authentication</div>
                    <p>For simple API access with rate limiting</p>
                </div>

                <h3>Data Mapping and Transformation</h3>
                <div class="code-block">
# Banking API Data Integration
import aiohttp
import asyncio
from typing import Dict, Any, List, Optional
import json
import logging

logger = logging.getLogger(__name__)

class BankingApiIntegrator:
    """
    Integrates with banking systems to collect regulatory data
    Handles API authentication, data mapping, and error recovery
    """

    def __init__(self,
                 api_base_url: str,
                 auth_method: str = 'oauth2',
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        self.api_base_url = api_base_url.rstrip('/')
        self.auth_method = auth_method
        self.client_id = client_id
        self.client_secret = client_secret
        self.access_token = None
        self.session = None
        self.data_mappings = self._load_data_mappings()

    def _load_data_mappings(self) -> Dict[str, Any]:
        """Load data field mappings for different banking systems"""
        return {
            'sap': {
                'balance_sheet': {
                    'assets': 'BS_ASSETS',
                    'liabilities': 'BS_LIABILITIES',
                    'equity': 'BS_EQUITY'
                },
                'income_statement': {
                    'revenue': 'IS_REVENUE',
                    'expenses': 'IS_EXPENSES',
                    'net_income': 'IS_NET_INCOME'
                }
            },
            'temenos': {
                'customer_data': {
                    'customer_id': 'CUSTOMER_ID',
                    'risk_rating': 'RISK_SCORE',
                    'jurisdiction': 'COUNTRY_CODE'
                }
            }
        }

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def authenticate(self) -> bool:
        """Authenticate with banking API based on configured method"""
        if self.auth_method == 'oauth2':
            return await self._oauth2_authenticate()
        elif self.auth_method == 'jwt':
            return await self._jwt_authenticate()
        elif self.auth_method == 'api_key':
            return True  # API key handled in headers
        else:
            raise ValueError(f"Unsupported auth method: {self.auth_method}")

    async def _oauth2_authenticate(self) -> bool:
        """OAuth 2.0 client credentials authentication"""
        token_url = f"{self.api_base_url}/oauth/token"
        data = {
            'grant_type': 'client_credentials',
            'client_id': self.client_id,
            'client_secret': self.client_secret
        }

        try:
            async with self.session.post(token_url, data=data) as response:
                if response.status == 200:
                    token_data = await response.json()
                    self.access_token = token_data.get('access_token')
                    return True
                else:
                    logger.error(f"OAuth2 auth failed: {response.status}")
                    return False
        except Exception as e:
            logger.error(f"OAuth2 auth error: {str(e)}")
            return False

    async def _jwt_authenticate(self) -> bool:
        """JWT token authentication"""
        # Implementation for JWT auth would go here
        return True

    async def get_balance_sheet_data(self,
                                   banking_system: str,
                                   date_from: str,
                                   date_to: str) -> Dict[str, Any]:
        """
        Retrieve balance sheet data from banking system
        Args:
            banking_system: Type of banking system (sap, temenos, etc.)
            date_from: Start date for data retrieval
            date_to: End date for data retrieval
        Returns:
            Mapped balance sheet data
        """
        if not self.access_token and self.auth_method != 'api_key':
            if not await self.authenticate():
                raise Exception("Failed to authenticate with banking API")

        # Build API request
        endpoint = f"/api/balance-sheet"
        params = {
            'from_date': date_from,
            'to_date': date_to,
            'format': 'json'
        }

        headers = self._build_headers()

        try:
            async with self.session.get(
                f"{self.api_base_url}{endpoint}",
                params=params,
                headers=headers
            ) as response:
                if response.status == 200:
                    raw_data = await response.json()
                    return self._map_data(raw_data, banking_system, 'balance_sheet')
                else:
                    raise Exception(f"API request failed: {response.status}")
        except Exception as e:
            logger.error(f"Balance sheet data retrieval failed: {str(e)}")
            raise

    def _build_headers(self) -> Dict[str, str]:
        """Build appropriate headers based on auth method"""
        headers = {'Content-Type': 'application/json'}

        if self.auth_method == 'oauth2' and self.access_token:
            headers['Authorization'] = f'Bearer {self.access_token}'
        elif self.auth_method == 'jwt' and self.access_token:
            headers['Authorization'] = f'Bearer {self.access_token}'
        elif self.auth_method == 'api_key' and self.client_id:
            headers['X-API-Key'] = self.client_id

        return headers

    def _map_data(self,
                  raw_data: Dict[str, Any],
                  banking_system: str,
                  data_type: str) -> Dict[str, Any]:
        """
        Map banking system data to standardized format
        Args:
            raw_data: Raw data from banking API
            banking_system: Banking system type
            data_type: Type of data being mapped
        Returns:
            Standardized data format
        """
        mapping = self.data_mappings.get(banking_system, {}).get(data_type, {})

        if not mapping:
            logger.warning(f"No mapping found for {banking_system}:{data_type}")
            return raw_data

        mapped_data = {}
        for standard_field, system_field in mapping.items():
            if system_field in raw_data:
                mapped_data[standard_field] = raw_data[system_field]
            else:
                logger.warning(f"Field {system_field} not found in raw data")

        # Include any unmapped fields
        for key, value in raw_data.items():
            if key not in mapping.values():
                mapped_data[key] = value

        return mapped_data

    async def get_customer_risk_data(self,
                                   customer_ids: List[str],
                                   banking_system: str) -> List[Dict[str, Any]]:
        """
        Retrieve customer risk data for regulatory reporting
        Args:
            customer_ids: List of customer identifiers
            banking_system: Banking system type
        Returns:
            List of customer risk profiles
        """
        if not self.access_token and self.auth_method != 'api_key':
            if not await self.authenticate():
                raise Exception("Failed to authenticate with banking API")

        headers = self._build_headers()
        endpoint = f"/api/customers/risk-profile"

        try:
            payload = {'customer_ids': customer_ids}
            async with self.session.post(
                f"{self.api_base_url}{endpoint}",
                json=payload,
                headers=headers
            ) as response:
                if response.status == 200:
                    raw_data = await response.json()
                    return [self._map_data(customer, banking_system, 'customer_data')
                           for customer in raw_data.get('customers', [])]
                else:
                    raise Exception(f"Customer data API request failed: {response.status}")
        except Exception as e:
            logger.error(f"Customer risk data retrieval failed: {str(e)}")
            raise
                </div>
            </div>
        </div>

        <!-- Monitoring Tab -->
        <div id="monitoring" class="tab-content">
            <div class="section">
                <h2>Third-Party Integration Monitoring</h2>
                <p>Comprehensive monitoring and alerting for all third-party integrations.</p>

                <h3>Integration Health Checks</h3>
                <div class="code-block">
# Third-Party Integration Monitoring
import asyncio
import aiohttp
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import logging
import json

logger = logging.getLogger(__name__)

class IntegrationMonitor:
    """
    Monitors health and performance of third-party integrations
    Provides alerting and automated recovery mechanisms
    """

    def __init__(self, integrations_config: Dict[str, Any]):
        self.integrations = integrations_config
        self.health_status = {}
        self.session = None
        self.alert_thresholds = {
            'response_time': 5000,  # 5 seconds
            'error_rate': 0.05,     # 5% error rate
            'uptime': 0.99          # 99% uptime
        }

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def run_health_checks(self) -> Dict[str, Any]:
        """
        Run comprehensive health checks on all integrations
        Returns health status for each integration
        """
        results = {}

        for integration_name, config in self.integrations.items():
            logger.info(f"Running health check for {integration_name}")
            results[integration_name] = await self._check_integration_health(
                integration_name, config
            )

        # Update overall health status
        self.health_status = results
        self._log_health_summary(results)

        return results

    async def _check_integration_health(self,
                                      integration_name: str,
                                      config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Check health of a specific integration
        Args:
            integration_name: Name of the integration
            config: Integration configuration
        Returns:
            Health check results
        """
        health_result = {
            'status': 'unknown',
            'response_time': None,
            'last_check': datetime.now().isoformat(),
            'error_message': None,
            'metrics': {}
        }

        try:
            integration_type = config.get('type', 'api')

            if integration_type == 'api':
                health_result = await self._check_api_health(config)
            elif integration_type == 'sftp':
                health_result = await self._check_sftp_health(config)
            elif integration_type == 'database':
                health_result = await self._check_database_health(config)
            else:
                health_result['error_message'] = f"Unsupported integration type: {integration_type}"

        except Exception as e:
            health_result['status'] = 'error'
            health_result['error_message'] = str(e)
            logger.error(f"Health check failed for {integration_name}: {str(e)}")

        return health_result

    async def _check_api_health(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Check API integration health"""
        health_url = config.get('health_endpoint', config.get('base_url'))
        timeout = aiohttp.ClientTimeout(total=10)

        start_time = datetime.now()

        try:
            headers = config.get('headers', {})
            if 'auth_token' in config:
                headers['Authorization'] = f"Bearer {config['auth_token']}"

            async with self.session.get(
                health_url,
                headers=headers,
                timeout=timeout
            ) as response:
                response_time = (datetime.now() - start_time).total_seconds() * 1000

                if response.status in [200, 201, 202]:
                    return {
                        'status': 'healthy',
                        'response_time': response_time,
                        'last_check': datetime.now().isoformat(),
                        'metrics': {
                            'status_code': response.status,
                            'response_time_ms': response_time
                        }
                    }
                else:
                    return {
                        'status': 'unhealthy',
                        'response_time': response_time,
                        'last_check': datetime.now().isoformat(),
                        'error_message': f"HTTP {response.status}",
                        'metrics': {
                            'status_code': response.status,
                            'response_time_ms': response_time
                        }
                    }

        except asyncio.TimeoutError:
            return {
                'status': 'timeout',
                'last_check': datetime.now().isoformat(),
                'error_message': 'Request timeout',
                'metrics': {'timeout_seconds': 10}
            }
        except Exception as e:
            return {
                'status': 'error',
                'last_check': datetime.now().isoformat(),
                'error_message': str(e)
            }

    async def _check_sftp_health(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Check SFTP integration health"""
        # SFTP health check implementation would go here
        # This would test connection, authentication, and basic file operations
        return {
            'status': 'healthy',  # Placeholder
            'last_check': datetime.now().isoformat(),
            'metrics': {'connection_time_ms': 150}
        }

    async def _check_database_health(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Check database integration health"""
        # Database health check implementation would go here
        # This would test connection, query execution, and basic operations
        return {
            'status': 'healthy',  # Placeholder
            'last_check': datetime.now().isoformat(),
            'metrics': {'connection_time_ms': 50}
        }

    def _log_health_summary(self, results: Dict[str, Any]):
        """Log summary of health check results"""
        healthy_count = sum(1 for r in results.values() if r['status'] == 'healthy')
        total_count = len(results)

        logger.info(f"Integration Health Summary: {healthy_count}/{total_count} integrations healthy")

        for integration, result in results.items():
            if result['status'] != 'healthy':
                logger.warning(f"Unhealthy integration: {integration} - {result.get('error_message', 'Unknown error')}")

    async def get_integration_metrics(self) -> Dict[str, Any]:
        """
        Get comprehensive metrics for all integrations
        Returns aggregated metrics and trends
        """
        metrics = {
            'timestamp': datetime.now().isoformat(),
            'overall_health': self._calculate_overall_health(),
            'integrations': {},
            'alerts': []
        }

        for integration_name, status in self.health_status.items():
            metrics['integrations'][integration_name] = {
                'status': status['status'],
                'response_time': status.get('response_time'),
                'last_check': status['last_check'],
                'error_rate': self._calculate_error_rate(integration_name)
            }

        # Generate alerts based on thresholds
        metrics['alerts'] = self._generate_alerts(metrics)

        return metrics

    def _calculate_overall_health(self) -> float:
        """Calculate overall health percentage"""
        if not self.health_status:
            return 0.0

        healthy_count = sum(1 for s in self.health_status.values() if s['status'] == 'healthy')
        return (healthy_count / len(self.health_status)) * 100

    def _calculate_error_rate(self, integration_name: str) -> float:
        """Calculate error rate for an integration (placeholder)"""
        # In a real implementation, this would track errors over time
        return 0.02  # 2% error rate

    def _generate_alerts(self, metrics: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate alerts based on health metrics"""
        alerts = []

        for integration_name, integration_metrics in metrics['integrations'].items():
            if integration_metrics['status'] != 'healthy':
                alerts.append({
                    'level': 'critical',
                    'integration': integration_name,
                    'message': f"Integration {integration_name} is {integration_metrics['status']}",
                    'timestamp': datetime.now().isoformat()
                })

            if integration_metrics.get('response_time', 0) > self.alert_thresholds['response_time']:
                alerts.append({
                    'level': 'warning',
                    'integration': integration_name,
                    'message': f"High response time: {integration_metrics['response_time']}ms",
                    'timestamp': datetime.now().isoformat()
                })

            if integration_metrics.get('error_rate', 0) > self.alert_thresholds['error_rate']:
                alerts.append({
                    'level': 'warning',
                    'integration': integration_name,
                    'message': f"High error rate: {integration_metrics['error_rate']*100:.1f}%",
                    'timestamp': datetime.now().isoformat()
                })

        return alerts
                </div>

                <h3>Alert Configuration</h3>
                <div class="config-table">
                    <thead>
                        <tr>
                            <th>Alert Type</th>
                            <th>Threshold</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Response Time</td>
                            <td>&gt; 5 seconds</td>
                            <td>Email + Slack notification</td>
                        </tr>
                        <tr>
                            <td>Error Rate</td>
                            <td>&gt; 5%</td>
                            <td>Page on-call engineer</td>
                        </tr>
                        <tr>
                            <td>Integration Down</td>
                            <td>N/A</td>
                            <td>Immediate escalation</td>
                        </tr>
                        <tr>
                            <td>Data Quality</td>
                            <td>&lt; 95% completeness</td>
                            <td>Warning notification</td>
                        </tr>
                    </tbody>
                </div>
            </div>
        </div>

        <!-- Security Tab -->
        <div id="security" class="tab-content">
            <div class="section">
                <h2>Security Best Practices</h2>
                <p>Security measures for third-party integrations to ensure regulatory compliance and data protection.</p>

                <h3>Authentication & Authorization</h3>
                <div class="warning">
                    <strong>Security Requirements:</strong>
                    <ul>
                        <li>Use OAuth 2.0 or JWT for API authentication</li>
                        <li>Implement certificate-based authentication for high-security systems</li>
                        <li>Use API keys only for low-risk, internal systems</li>
                        <li>Rotate credentials every 90 days</li>
                        <li>Implement multi-factor authentication where supported</li>
                    </ul>
                </div>

                <h3>Data Encryption</h3>
                <div class="success">
                    <strong>Encryption Standards:</strong>
                    <ul>
                        <li>AES-256-GCM for data at rest</li>
                        <li>TLS 1.3 for data in transit</li>
                        <li>Digital signatures for report integrity</li>
                        <li>End-to-end encryption for sensitive data</li>
                    </ul>
                </div>

                <h3>Security Implementation</h3>
                <div class="code-block">
# Security Implementation for Third-Party Integrations
import hashlib
import hmac
import json
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization
from datetime import datetime
from typing import Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)

class SecurityManager:
    """
    Manages security for third-party integrations
    Handles encryption, digital signatures, and secure communication
    """

    def __init__(self, private_key_path: Optional[str] = None, public_key_path: Optional[str] = None):
        self.private_key = None
        self.public_key = None

        if private_key_path:
            self._load_private_key(private_key_path)
        if public_key_path:
            self._load_public_key(public_key_path)

    def _load_private_key(self, key_path: str):
        """Load RSA private key for signing"""
        try:
            with open(key_path, 'rb') as f:
                self.private_key = serialization.load_pem_private_key(
                    f.read(),
                    password=None
                )
            logger.info("Private key loaded successfully")
        except Exception as e:
            logger.error(f"Failed to load private key: {str(e)}")
            raise

    def _load_public_key(self, key_path: str):
        """Load RSA public key for verification"""
        try:
            with open(key_path, 'rb') as f:
                self.public_key = serialization.load_pem_public_key(f.read())
            logger.info("Public key loaded successfully")
        except Exception as e:
            logger.error(f"Failed to load public key: {str(e)}")
            raise

    def generate_api_key(self, client_id: str, permissions: List[str]) -> str:
        """
        Generate secure API key for client
        Args:
            client_id: Unique client identifier
            permissions: List of permissions for the client
        Returns:
            Secure API key
        """
        # Create payload with client info and timestamp
        payload = {
            'client_id': client_id,
            'permissions': permissions,
            'issued_at': datetime.now().isoformat(),
            'expires_at': (datetime.now().replace(hour=23, minute=59, second=59)).isoformat()
        }

        # Convert to JSON string and hash
        payload_str = json.dumps(payload, sort_keys=True)
        api_key = hashlib.sha256(payload_str.encode()).hexdigest()[:32]

        return api_key

    def create_digital_signature(self, data: Dict[str, Any]) -> str:
        """
        Create digital signature for data integrity
        Args:
            data: Data to sign
        Returns:
            Base64 encoded signature
        """
        if not self.private_key:
            raise Exception("Private key not loaded")

        # Convert data to canonical JSON string
        data_str = json.dumps(data, sort_keys=True, separators=(',', ':'))

        # Create signature
        signature = self.private_key.sign(
            data_str.encode(),
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )

        # Return base64 encoded signature
        import base64
        return base64.b64encode(signature).decode()

    def verify_digital_signature(self, data: Dict[str, Any], signature: str) -> bool:
        """
        Verify digital signature
        Args:
            data: Original data
            signature: Base64 encoded signature to verify
        Returns:
            True if signature is valid
        """
        if not self.public_key:
            raise Exception("Public key not loaded")

        try:
            # Convert data to canonical JSON string
            data_str = json.dumps(data, sort_keys=True, separators=(',', ':'))

            # Decode signature
            import base64
            signature_bytes = base64.b64decode(signature)

            # Verify signature
            self.public_key.verify(
                signature_bytes,
                data_str.encode(),
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True
        except Exception as e:
            logger.error(f"Signature verification failed: {str(e)}")
            return False

    def encrypt_sensitive_data(self, data: str, key: str) -> str:
        """
        Encrypt sensitive data using AES-256-GCM
        Args:
            data: Data to encrypt
            key: Encryption key
        Returns:
            Encrypted data with nonce and tag
        """
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        import os

        # Generate nonce
        nonce = os.urandom(12)

        # Create cipher
        cipher = Cipher(algorithms.AES(key.encode()[:32]), modes.GCM(nonce))
        encryptor = cipher.encryptor()

        # Encrypt data
        ciphertext = encryptor.update(data.encode()) + encryptor.finalize()

        # Combine nonce, ciphertext, and tag
        import base64
        encrypted_data = base64.b64encode(nonce + ciphertext + encryptor.tag).decode()

        return encrypted_data

    def decrypt_sensitive_data(self, encrypted_data: str, key: str) -> str:
        """
        Decrypt sensitive data
        Args:
            encrypted_data: Encrypted data with nonce and tag
            key: Decryption key
        Returns:
            Decrypted data
        """
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

        # Decode encrypted data
        import base64
        encrypted_bytes = base64.b64decode(encrypted_data)

        # Extract nonce, ciphertext, and tag
        nonce = encrypted_bytes[:12]
        tag = encrypted_bytes[-16:]
        ciphertext = encrypted_bytes[12:-16]

        # Create cipher
        cipher = Cipher(algorithms.AES(key.encode()[:32]), modes.GCM(nonce, tag))
        decryptor = cipher.decryptor()

        # Decrypt data
        decrypted_data = decryptor.update(ciphertext) + decryptor.finalize()

        return decrypted_data.decode()

    def create_hmac_signature(self, data: str, secret: str) -> str:
        """
        Create HMAC signature for API request integrity
        Args:
            data: Request data
            secret: Shared secret
        Returns:
            HMAC signature
        """
        import base64
        hmac_signature = hmac.new(
            secret.encode(),
            data.encode(),
            hashlib.sha256
        ).digest()

        return base64.b64encode(hmac_signature).decode()

    def validate_request_integrity(self,
                                 request_data: str,
                                 provided_signature: str,
                                 secret: str) -> bool:
        """
        Validate request integrity using HMAC
        Args:
            request_data: Original request data
            provided_signature: HMAC signature from request
            secret: Shared secret
        Returns:
            True if signature is valid
        """
        expected_signature = self.create_hmac_signature(request_data, secret)

        # Use constant-time comparison to prevent timing attacks
        return hmac.compare_digest(expected_signature, provided_signature)
                </div>

                <h3>Compliance Monitoring</h3>
                <div class="highlight">
                    <strong>Regulatory Compliance Checks:</strong>
                    <ul>
                        <li>GDPR compliance for data handling</li>
                        <li>PSD2 requirements for payment data</li>
                        <li>AML regulations for customer data</li>
                        <li>SOX compliance for financial reporting</li>
                        <li>Regular security audits and penetration testing</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>&copy; 2024 ComplianceAI. Third-Party Integration Guide v2.0</p>
        <p>For technical support, contact the ComplianceAI development team.</p>
    </div>

    <script>
        function showTab(tabName) {
            // Hide all tabs
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.classList.remove('active'));

            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.nav-tab');
            tabButtons.forEach(button => button.classList.remove('active'));

            // Show selected tab
            document.getElementById(tabName).classList.add('active');

            // Add active class to clicked button
            event.target.classList.add('active');
        }
    </script>
</body>
</html>
